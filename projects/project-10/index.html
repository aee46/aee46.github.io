<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://aee46.github.io name=base><title>
         Lab 10
        
    </title><meta content="Lab 10" property=og:title><meta content="Localization - Simulation" property=og:description><meta content="Localization - Simulation" name=description><link href=/icon/favicon.png rel=icon type=image/png><link href=https://aee46.github.io/fonts.css rel=stylesheet><script src=https://aee46.github.io/js/codeblock.js></script><script src=https://aee46.github.io/js/toc.js></script><script src=https://aee46.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="ECE 4160" href=https://aee46.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://aee46.github.io/theme/light.css rel=stylesheet><link href=https://aee46.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://aee46.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://aee46.github.io/main.css media=screen rel=stylesheet><script src=https://aee46.github.io/js/mermaid.js></script><body><div class=content><header><div class=main><a href=https://aee46.github.io>ECE 4160</a></div><nav><a href=https://aee46.github.io/projects style=margin-left:.25em>/labs</a><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://aee46.github.io/feather/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://aee46.github.io/feather/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>Lab 10<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta></div></div><div class=toc-container><h1 class=toc-title>Table of Contents</h1><ul class=toc-list><li><a href=https://aee46.github.io/projects/project-10/#lab-10-simulating-robot-localization>Lab 10 - Simulating Robot Localization</a><li><a href=https://aee46.github.io/projects/project-10/#filter-functions>Filter Functions</a><li><a href=https://aee46.github.io/projects/project-10/#compute-control>COMPUTE_CONTROL()</a><li><a href=https://aee46.github.io/projects/project-10/#odom-motion-model>ODOM_MOTION_MODEL()</a><li><a href=https://aee46.github.io/projects/project-10/#prediction-step>PREDICTION_STEP()</a><li><a href=https://aee46.github.io/projects/project-10/#sensor-model>SENSOR_MODEL()</a><li><a href=https://aee46.github.io/projects/project-10/#running-the-bayes-filter>Running the Bayes Filter</a><li><a href=https://aee46.github.io/projects/project-10/#acknowledgements>Acknowledgements</a></ul></div><section class=body><h1 id=lab-10-simulating-robot-localization>Lab 10 - Simulating Robot Localization</h1><p>Now that the robot is capable of mapping its global environment, as demonstrated in Lab 9, it is time to implement localization. For this lab, the localization will take place in a simulated virtual environment. Robot localization allows a robot to map its immediate surroundings to determine its position within a global map.<p>To execute localization, we use the Bayes Filter. This filter incorporates sensor data, control inputs, and the robot's prior belief about its location to compute a probabilistic estimate of its location. Our robot's location has been discretized in order to reduce space complexity. The robot's location is represented by its x-y location and its current yaw rotation. These values make up a 12x9x18 size array, representing the robot's complete global environment.<h1 id=filter-functions>Filter Functions</h1><p>As with any programming task, it is crucial to break down the localization problem into smaller subtasks. I will now explain each function that I implemented that are used by the full Bayes Filter.<h1 id=compute-control>COMPUTE_CONTROL()</h1><p>This function takes the robot's current and previous poses and compute the control inputs that resulted in the change in pose. Each pose is represented as an array of [x, y, theta] data. The relevant control inputs are translation, initial rotation, and final rotation. Distance values are recorded in meters, while rotation data is recorded in degrees and normalized between -180 and +180 degrees.<pre class=language-Python data-lang=Python style=color:#61676c;background-color:#fafafa><code class=language-Python data-lang=Python><span style=color:#fa6e32>def </span><span style=color:#f29718>compute_control</span><span>(</span><span style=color:#ff8f40>cur_pose</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>prev_pose</span><span>):
</span><span>    </span><span style=color:#abb0b6;font-style:italic>""" Given the current and previous odometry poses, this function extracts
</span><span style=color:#abb0b6;font-style:italic>    the control information based on the odometry motion model.
</span><span style=color:#abb0b6;font-style:italic>
</span><span style=color:#abb0b6;font-style:italic>    Args:
</span><span style=color:#abb0b6;font-style:italic>        cur_pose  ([Pose]): Current Pose
</span><span style=color:#abb0b6;font-style:italic>        prev_pose ([Pose]): Previous Pose 
</span><span style=color:#abb0b6;font-style:italic>
</span><span style=color:#abb0b6;font-style:italic>    Returns:
</span><span style=color:#abb0b6;font-style:italic>        [delta_rot_1]: Rotation 1  (degrees)
</span><span style=color:#abb0b6;font-style:italic>        [delta_trans]: Translation (meters)
</span><span style=color:#abb0b6;font-style:italic>        [delta_rot_2]: Rotation 2  (degrees)
</span><span style=color:#abb0b6;font-style:italic>    """
</span><span>    </span><span style=color:#abb0b6;font-style:italic># Take input arrays, unpack specific position data
</span><span>    current_x </span><span style=color:#ed9366>= </span><span>cur_pose[</span><span style=color:#ff8f40>0</span><span>]
</span><span>    current_y </span><span style=color:#ed9366>= </span><span>cur_pose[</span><span style=color:#ff8f40>1</span><span>]
</span><span>    current_theta </span><span style=color:#ed9366>= </span><span>cur_pose[</span><span style=color:#ff8f40>2</span><span>]
</span><span>    previous_x </span><span style=color:#ed9366>= </span><span>prev_pose[</span><span style=color:#ff8f40>0</span><span>]
</span><span>    previous_y </span><span style=color:#ed9366>= </span><span>prev_pose[</span><span style=color:#ff8f40>1</span><span>]
</span><span>    previous_theta </span><span style=color:#ed9366>= </span><span>prev_pose[</span><span style=color:#ff8f40>2</span><span>]
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic># Calculate change in position
</span><span>    dx </span><span style=color:#ed9366>= </span><span>current_x </span><span style=color:#ed9366>- </span><span>previous_x
</span><span>    dy </span><span style=color:#ed9366>= </span><span>current_y </span><span style=color:#ed9366>- </span><span>previous_y
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic># Calculate control variables using equation from lecture slides
</span><span>    delta_rot_1 </span><span style=color:#ed9366>= </span><span>mapper</span><span style=color:#ed9366>.</span><span style=color:#f29718>normalize_angle</span><span>(np</span><span style=color:#ed9366>.</span><span style=color:#f29718>degrees</span><span>(np</span><span style=color:#ed9366>.</span><span style=color:#f29718>arctan2</span><span>(dy</span><span style=color:#61676ccc>, </span><span>dx)) </span><span style=color:#ed9366>- </span><span>previous_theta)
</span><span>    delta_trans </span><span style=color:#ed9366>= </span><span>np</span><span style=color:#ed9366>.</span><span style=color:#f29718>hypot</span><span>(dy</span><span style=color:#61676ccc>, </span><span>dx)
</span><span>    delta_rot_2 </span><span style=color:#ed9366>= </span><span>mapper</span><span style=color:#ed9366>.</span><span style=color:#f29718>normalize_angle</span><span>(current_theta </span><span style=color:#ed9366>- </span><span>previous_theta </span><span style=color:#ed9366>- </span><span>delta_rot_1)
</span><span>
</span><span>    </span><span style=color:#fa6e32>return </span><span>delta_rot_1, delta_trans, delta_rot_2
</span></code></pre><h1 id=odom-motion-model>ODOM_MOTION_MODEL()</h1><p>This function takes in both the current and previous pose, as well as the control inputs that made the robot move between these two states. The function calculates the ideal control inputs to move between these states and then calculates the probability that the robot is in the current states. In other words, given the control inputs and the robot's previous state, we can calculate the conditional probaility that it is in its current state.<pre class=language-Python data-lang=Python style=color:#61676c;background-color:#fafafa><code class=language-Python data-lang=Python><span style=color:#fa6e32>def </span><span style=color:#f29718>odom_motion_model</span><span>(</span><span style=color:#ff8f40>cur_pose</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>prev_pose</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>u</span><span>):
</span><span>    </span><span style=color:#abb0b6;font-style:italic>""" Odometry Motion Model
</span><span style=color:#abb0b6;font-style:italic>
</span><span style=color:#abb0b6;font-style:italic>    Args:
</span><span style=color:#abb0b6;font-style:italic>        cur_pose  ([Pose]): Current Pose
</span><span style=color:#abb0b6;font-style:italic>        prev_pose ([Pose]): Previous Pose
</span><span style=color:#abb0b6;font-style:italic>        (rot1, trans, rot2) (float, float, float): A tuple with control data in the format 
</span><span style=color:#abb0b6;font-style:italic>                                                   format (rot1, trans, rot2) with units (degrees, meters, degrees)
</span><span style=color:#abb0b6;font-style:italic>    Returns:
</span><span style=color:#abb0b6;font-style:italic>        prob [float]: Probability p(x'|x, u)
</span><span style=color:#abb0b6;font-style:italic>    """
</span><span>    </span><span style=color:#abb0b6;font-style:italic># Compute Control Variables
</span><span>    delta_rot_1, delta_trans, delta_rot_2 </span><span style=color:#ed9366>= </span><span style=color:#f29718>compute_control</span><span>(cur_pose</span><span style=color:#61676ccc>, </span><span>prev_pose)
</span><span>    </span><span style=color:#abb0b6;font-style:italic># Calculate Probability of next state given previous states
</span><span>    prob_rot_1 </span><span style=color:#ed9366>= </span><span>loc</span><span style=color:#ed9366>.</span><span style=color:#f29718>gaussian</span><span>(delta_rot_1</span><span style=color:#61676ccc>, </span><span>u[</span><span style=color:#ff8f40>0</span><span>]</span><span style=color:#61676ccc>, </span><span>loc</span><span style=color:#ed9366>.</span><span>odom_rot_sigma)
</span><span>    prob_trans </span><span style=color:#ed9366>= </span><span>loc</span><span style=color:#ed9366>.</span><span style=color:#f29718>gaussian</span><span>(delta_trans</span><span style=color:#61676ccc>, </span><span>u[</span><span style=color:#ff8f40>1</span><span>]</span><span style=color:#61676ccc>, </span><span>loc</span><span style=color:#ed9366>.</span><span>odom_trans_sigma)
</span><span>    prob_rot_2 </span><span style=color:#ed9366>= </span><span>loc</span><span style=color:#ed9366>.</span><span style=color:#f29718>gaussian</span><span>(delta_rot_2</span><span style=color:#61676ccc>, </span><span>u[</span><span style=color:#ff8f40>2</span><span>]</span><span style=color:#61676ccc>, </span><span>loc</span><span style=color:#ed9366>.</span><span>odom_rot_sigma)
</span><span>    </span><span style=color:#abb0b6;font-style:italic># Total Probability 
</span><span>    prob </span><span style=color:#ed9366>= </span><span>prob_rot_1 </span><span style=color:#ed9366>* </span><span>prob_trans </span><span style=color:#ed9366>* </span><span>prob_rot_2
</span><span>
</span><span>    </span><span style=color:#fa6e32>return </span><span>prob
</span></code></pre><h1 id=prediction-step>PREDICTION_STEP()</h1><p>This function takes in both the current and previous odometry state data (pose). Using this data, the function iterates over the entire grid of all possible robot states and determines the prior belief that the robot was in a given state. If this prior belief is above a certain threshold (0.0001), we continue. Having this threshold decreases computation time without significantly affecting the filter's accuracy. For each state that has an above-threshold proability, we iterate over each state and calculate the probability that the robot moved from the prior state to its current state given the control inputs for this transition.<pre class=language-Python data-lang=Python style=color:#61676c;background-color:#fafafa><code class=language-Python data-lang=Python><span style=color:#fa6e32>def </span><span style=color:#f29718>prediction_step</span><span>(</span><span style=color:#ff8f40>cur_odom</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>prev_odom</span><span>):
</span><span>    </span><span style=color:#abb0b6;font-style:italic>""" Prediction step of the Bayes Filter.
</span><span style=color:#abb0b6;font-style:italic>    Update the probabilities in loc.bel_bar based on loc.bel from the previous time step and the odometry motion model.
</span><span style=color:#abb0b6;font-style:italic>
</span><span style=color:#abb0b6;font-style:italic>    Args:
</span><span style=color:#abb0b6;font-style:italic>        cur_odom  ([Pose]): Current Pose
</span><span style=color:#abb0b6;font-style:italic>        prev_odom ([Pose]): Previous Pose
</span><span style=color:#abb0b6;font-style:italic>    """
</span><span>    </span><span style=color:#abb0b6;font-style:italic># Compute control values
</span><span>    u </span><span style=color:#ed9366>= </span><span style=color:#f29718>compute_control</span><span>(cur_odom</span><span style=color:#61676ccc>, </span><span>prev_odom)
</span><span>    </span><span style=color:#abb0b6;font-style:italic># Initialize bel_bar array. This array holds the probability of the robot being in each possible state in 3D (x, y, theta)
</span><span>    loc</span><span style=color:#ed9366>.</span><span>bel_bar </span><span style=color:#ed9366>= </span><span>np</span><span style=color:#ed9366>.</span><span style=color:#f29718>zeros</span><span>((mapper</span><span style=color:#ed9366>.</span><span>MAX_CELLS_X</span><span style=color:#61676ccc>, </span><span>mapper</span><span style=color:#ed9366>.</span><span>MAX_CELLS_Y</span><span style=color:#61676ccc>, </span><span>mapper</span><span style=color:#ed9366>.</span><span>MAX_CELLS_A))
</span><span>
</span><span>    </span><span style=color:#fa6e32>for </span><span>i </span><span style=color:#fa6e32>in </span><span style=color:#f07171>range</span><span>(mapper</span><span style=color:#ed9366>.</span><span>MAX_CELLS_X):
</span><span>        </span><span style=color:#fa6e32>for </span><span>j </span><span style=color:#fa6e32>in </span><span style=color:#f07171>range</span><span>(mapper</span><span style=color:#ed9366>.</span><span>MAX_CELLS_Y):
</span><span>            </span><span style=color:#fa6e32>for </span><span>k </span><span style=color:#fa6e32>in </span><span style=color:#f07171>range</span><span>(mapper</span><span style=color:#ed9366>.</span><span>MAX_CELLS_A):
</span><span>                prior_bel </span><span style=color:#ed9366>= </span><span>loc</span><span style=color:#ed9366>.</span><span>bel[i, j, k]
</span><span>                </span><span style=color:#fa6e32>if </span><span>prior_bel </span><span style=color:#ed9366>> </span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>.</span><span style=color:#ff8f40>0001</span><span>:
</span><span>                    previous_pose </span><span style=color:#ed9366>= </span><span>mapper</span><span style=color:#ed9366>.</span><span style=color:#f29718>from_map</span><span>(i</span><span style=color:#61676ccc>, </span><span>j</span><span style=color:#61676ccc>, </span><span>k)
</span><span>                    </span><span style=color:#fa6e32>for </span><span>a </span><span style=color:#fa6e32>in </span><span style=color:#f07171>range</span><span>(mapper</span><span style=color:#ed9366>.</span><span>MAX_CELLS_X):
</span><span>                        </span><span style=color:#fa6e32>for </span><span>b </span><span style=color:#fa6e32>in </span><span style=color:#f07171>range</span><span>(mapper</span><span style=color:#ed9366>.</span><span>MAX_CELLS_Y):
</span><span>                            </span><span style=color:#fa6e32>for </span><span>c </span><span style=color:#fa6e32>in </span><span style=color:#f07171>range</span><span>(mapper</span><span style=color:#ed9366>.</span><span>MAX_CELLS_A):
</span><span>                                current_pose </span><span style=color:#ed9366>= </span><span>mapper</span><span style=color:#ed9366>.</span><span style=color:#f29718>from_map</span><span>(a</span><span style=color:#61676ccc>, </span><span>b</span><span style=color:#61676ccc>, </span><span>c)
</span><span>                                probability </span><span style=color:#ed9366>= </span><span style=color:#f29718>odom_motion_model</span><span>(current_pose</span><span style=color:#61676ccc>, </span><span>previous_pose</span><span style=color:#61676ccc>, </span><span>u)
</span><span>                                loc</span><span style=color:#ed9366>.</span><span>bel_bar[a,b,c] </span><span style=color:#ed9366>+= </span><span>probability </span><span style=color:#ed9366>* </span><span>loc</span><span style=color:#ed9366>.</span><span>bel[i,j,k]
</span><span>    loc</span><span style=color:#ed9366>.</span><span>bel_bar </span><span style=color:#ed9366>= </span><span>loc</span><span style=color:#ed9366>.</span><span>bel_bar </span><span style=color:#ed9366>/ </span><span>np</span><span style=color:#ed9366>.</span><span style=color:#f29718>sum</span><span>(loc</span><span style=color:#ed9366>.</span><span>bel_bar)
</span></code></pre><h1 id=sensor-model>SENSOR_MODEL()</h1><p>Now that we've modeled the motion of the robot, we need to model the robot's TOF sensor. Given the robot's current state, we calculate the probability that a specific TOF sensor reading will occur. A gaussian distribution is used for this model (as in the motion model) using a ground truth expectation as the distribution's mean and a variance corresponding to the sensor's noise. For each state, the robot rotates through 18 angles to measure TOF data.<pre class=language-Python data-lang=Python style=color:#61676c;background-color:#fafafa><code class=language-Python data-lang=Python><span style=color:#fa6e32>def </span><span style=color:#f29718>sensor_model</span><span>(</span><span style=color:#ff8f40>obs</span><span>):
</span><span>    </span><span style=color:#abb0b6;font-style:italic>""" This is the equivalent of p(z|x).
</span><span style=color:#abb0b6;font-style:italic>
</span><span style=color:#abb0b6;font-style:italic>
</span><span style=color:#abb0b6;font-style:italic>    Args:
</span><span style=color:#abb0b6;font-style:italic>        obs ([ndarray]): A 1D array consisting of the true observations for a specific robot pose in the map 
</span><span style=color:#abb0b6;font-style:italic>
</span><span style=color:#abb0b6;font-style:italic>    Returns:
</span><span style=color:#abb0b6;font-style:italic>        [ndarray]: Returns a 1D array of size 18 (=mapper.OBS_PER_CELL) with the likelihoods of each individual sensor measurement
</span><span style=color:#abb0b6;font-style:italic>    """
</span><span>    prob_array </span><span style=color:#ed9366>= </span><span>[]
</span><span>    </span><span style=color:#fa6e32>for </span><span>i </span><span style=color:#fa6e32>in </span><span style=color:#f07171>range</span><span>(mapper</span><span style=color:#ed9366>.</span><span>OBS_PER_CELL):
</span><span>        prob </span><span style=color:#ed9366>= </span><span>loc</span><span style=color:#ed9366>.</span><span style=color:#f29718>gaussian</span><span>(obs[i]</span><span style=color:#61676ccc>, </span><span>loc</span><span style=color:#ed9366>.</span><span>obs_range_data[i]</span><span style=color:#61676ccc>, </span><span>loc</span><span style=color:#ed9366>.</span><span>sensor_sigma)
</span><span>        prob_array</span><span style=color:#ed9366>.</span><span style=color:#f29718>append</span><span>(prob)
</span><span>
</span><span>    </span><span style=color:#fa6e32>return </span><span>prob_array
</span></code></pre><p>UPDATE_STEP() Finally, using all of our predictions and models, we update the robot's belief about its current position in its environment. The function uses both the robot's prior belief about its position and its sensor model data to calculate a list of probabilities representing how likely the robot is to be in each possible state. This distribution is normalized, and we take the position/orientation that is most probable to be the robot's current position.<pre class=language-Python data-lang=Python style=color:#61676c;background-color:#fafafa><code class=language-Python data-lang=Python><span style=color:#fa6e32>def </span><span style=color:#f29718>update_step</span><span>():
</span><span>    </span><span style=color:#abb0b6;font-style:italic>""" Update step of the Bayes Filter.
</span><span style=color:#abb0b6;font-style:italic>    Update the probabilities in loc.bel based on loc.bel_bar and the sensor model.
</span><span style=color:#abb0b6;font-style:italic>    """
</span><span>    </span><span style=color:#fa6e32>for </span><span>i </span><span style=color:#fa6e32>in </span><span style=color:#f07171>range</span><span>(mapper</span><span style=color:#ed9366>.</span><span>MAX_CELLS_X):
</span><span>        </span><span style=color:#fa6e32>for </span><span>j </span><span style=color:#fa6e32>in </span><span style=color:#f07171>range</span><span>(mapper</span><span style=color:#ed9366>.</span><span>MAX_CELLS_Y):
</span><span>            </span><span style=color:#fa6e32>for </span><span>k </span><span style=color:#fa6e32>in </span><span style=color:#f07171>range</span><span>(mapper</span><span style=color:#ed9366>.</span><span>MAX_CELLS_A):
</span><span>                probability </span><span style=color:#ed9366>= </span><span>np</span><span style=color:#ed9366>.</span><span style=color:#f29718>prod</span><span>(</span><span style=color:#f29718>sensor_model</span><span>(mapper</span><span style=color:#ed9366>.</span><span style=color:#f29718>get_views</span><span>(i</span><span style=color:#61676ccc>, </span><span>j</span><span style=color:#61676ccc>, </span><span>k)))
</span><span>                loc</span><span style=color:#ed9366>.</span><span>bel[i, j, k] </span><span style=color:#ed9366>= </span><span>probability </span><span style=color:#ed9366>* </span><span>loc</span><span style=color:#ed9366>.</span><span>bel_bar[i, j, k]
</span><span>    loc</span><span style=color:#ed9366>.</span><span>bel </span><span style=color:#ed9366>/= </span><span>np</span><span style=color:#ed9366>.</span><span style=color:#f29718>sum</span><span>(loc</span><span style=color:#ed9366>.</span><span>bel)
</span></code></pre><h1 id=running-the-bayes-filter>Running the Bayes Filter</h1><p>Now that the Bayes Filter has been implemented, I ran a simulation using the provided source code to model the robot's estimated position throughout a given trajectory. In the video below, three plots are shown. In green is the robot's ground truth position. This represents the robot's ideal position and orientation. In blue is the output of the Bayes Filter, representing the robot's predicted pose values. Finally, in red, is a model that uses raw odometry data without any probablistic modeling to estimate the robot's position. It is clear that the Bayes filter performs much better -- especially near walls, where the TOF sensor data is more accurate -- compared to the odoemetry model.</p><center><a href="https://www.youtube.com/watch?v=wJtF6n-7qlk" title=Scope><img alt=Scope height=300 src=/projects/lab10vid.PNG width=400></a></center><h1 id=acknowledgements>Acknowledgements</h1><p>I referenced Stephan Wagner's and Daria Kot's 2024 Webpages while completing this lab.</section></article></main></div>